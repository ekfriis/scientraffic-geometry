#!/usr/bin/env python

'''

Find the voronoi diagram of a set of points.

Author: Evan K. Friis

'''

import argparse
import itertools
import geojson
import logging
import operator
import random

import numpy as np
from scipy.spatial import Voronoi

from descartes import PolygonPatch
from shapely.geometry import MultiPolygon, MultiLineString, Polygon
#from shapely.geometry import mapping
from shapely.ops import cascaded_union, polygonize
from shapely.validation import explain_validity
import matplotlib.pyplot as plt

import topotools

log = logging.getLogger(__name__)

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'input', metavar='communities.gz',
        help='Gzipped communities, generated by communities.py')
    parser.add_argument(
        'output', metavar='community_shapes.gz',
        help='Gzipped WKT output polygons')

    parser.add_argument(
        '--draw-prune', dest='drawprune', type=int, nargs='+',
        help='Draw voronoi pruning debug diagram')

    parser.add_argument(
        '--draw', help='Draw voronoi diagram')

    parser.add_argument('--bbox', nargs=4, type=float, metavar='x',
                        help='Only consider nodes within bbox')

    parser.add_argument('--AND', dest="and_shapes", nargs='+', type=str,
                        default=[], metavar='file.shp',
                        help='List of .shp files to '
                        'AND the output shapes with')

    parser.add_argument('--seed', default=1, type=int, help='random seed')

    args = parser.parse_args()

    logging.basicConfig()
    log.setLevel(logging.INFO)
    topotools.log.setLevel(logging.INFO)

    random.seed(args.seed)

    clustered_nodes = itertools.groupby(
        topotools.read_clusters(args.input, args.bbox),
        operator.attrgetter('clust')
    )

    pruned_nodes = []

    for clustidx, nodes in clustered_nodes:
        log.info("Pruning interior of cluster %i", clustidx)
        draw = None
        if args.drawprune and clustidx in args.drawprune:
            draw = 'prune_%i.png' % clustidx
        pruned = topotools.voronoi_prune_region(nodes, 25, draw=draw)
        pruned_nodes.extend(pruned)

    pruned_nodes.sort(key=operator.attrgetter('clust'))

    log.info("Generating full Voronoi from %i pruned nodes",
             len(pruned_nodes))

    max_lat = max([x.lat for x in pruned_nodes])
    min_lat = min([x.lat for x in pruned_nodes])
    max_lon = max([x.lon for x in pruned_nodes])
    min_lon = min([x.lon for x in pruned_nodes])

    bounding_box = Polygon(
        [(min_lon, min_lat), (max_lon, min_lat),
         (max_lon, max_lat), (min_lon, max_lat),
         (min_lon, min_lat)])

    # Find any relevant shapes in our AND shapefile
    bounding_polygon = None
    feature_count = 0
    for shp_file in args.and_shapes:
        log.info("Loading features from %s", shp_file)
        polys_in_shp_file = []
        for feature in topotools.shp_to_multipolygon(
                shp_file, overlapping=bounding_box):
            if not isinstance(feature, MultiPolygon):
                feature = [feature]
            for poly in feature:
                if bounding_box.intersects(poly):
                    feature_count += 1
                    interesting_part = poly.intersection(bounding_box)
                    polys_in_shp_file.append(interesting_part)
        shp_file_megapoly = cascaded_union(polys_in_shp_file)
        if bounding_polygon is None:
            bounding_polygon = shp_file_megapoly
        else:
            bounding_polygon = bounding_polygon.intersection(
                shp_file_megapoly)
    log.info("Found %i overlapping features", feature_count)

    voronoi = Voronoi(np.array(
        [(x.lon, x.lat) for x in pruned_nodes], dtype=float))

    log.info("Joining polygons")

    output_polygons = []

    # Loop over collections of node indices
    for clusteridx, node_iter in itertools.groupby(
            enumerate(pruned_nodes), lambda x: x[1].clust):

        # keep track of all paths in this cluster's
        # voronoi regions.
        cluster_polygons = []

        for node_idx, node in node_iter:
            #print clusteridx, node_idx, node.clust
            # Get the voronoi region of this point
            voronoi_region = voronoi.point_region[node_idx]
            vertices_idxs = voronoi.regions[voronoi_region]
            # ignore infinite cells
            if -1 in vertices_idxs:
                continue
            # add lines between all interior points
            points = [(tuple(voronoi.vertices[a]), tuple(voronoi.vertices[b]))
                      for a, b in itertools.combinations(vertices_idxs, 2)]
            ring = MultiLineString(points)
            polygons = list(polygonize([ring]))
            if not polygons:
                log.warning("No polygons detected in line, skipping")
                continue
            else:
                if not polygons[0].is_valid:
                    log.warning("Invalid polygon! %s",
                                explain_validity(polygons[0]))
                    polygons[0] = polygons[0].buffer(0)
                    log.warning("After cleaning validity = %i",
                                polygons[0].is_valid)
                cluster_polygons.append(polygons[0])

        log.info("Merging %i cluster polygons", len(cluster_polygons))
        polygon = cascaded_union(cluster_polygons)
        #import pdb
        #pdb.set_trace()
        log.info("Created polygon for cluster %i with area %0.2f",
                 clusteridx, polygon.area)

        if bounding_polygon is not None:
            polygon = polygon.intersection(bounding_polygon)
        log.info("After AND-ing, the area is: %0.2g", polygon.area)

        best_polygon = polygon
        original_area = polygon.area
        best_area = polygon.area

        if isinstance(polygon, MultiPolygon):
            best_area = 0
            log.info("Multi polygons detected")
            for ip, subpoly in enumerate(polygon):
                subpoly.cluster = clusteridx
                output_polygons.append(subpoly)
                #log.info("Poly %i - area: %f", ip, subpoly.area)
                if subpoly.area > best_area:
                    best_polygon = subpoly
                    best_area = subpoly.area
        else:
            best_polygon.cluster = clusteridx
            output_polygons.append(best_polygon)

    if args.draw:
        colors = ['red', 'green', 'blue', 'orange', 'PeachPuff',
                  'purple', 'cyan', 'Coral', 'FireBrick']
        figure = plt.figure()
        plt.gca().set_ylim((min_lat, max_lat))
        plt.gca().set_xlim((min_lon, max_lon))
        draw_points = False
        if draw_points:
            for clusteridx, node_iter in itertools.groupby(
                    pruned_nodes, operator.attrgetter('clust')):
                color_for_clust = colors[clusteridx % len(colors)]
                xy = np.array([(x.lon, x.lat) for x in node_iter], dtype=float)
                plt.plot(xy[:, 0], xy[:, 1], 'x',
                         color=color_for_clust, hold=1)
        for polygon in output_polygons:
            if not polygon:
                continue
            color_for_clust = colors[polygon.cluster % len(colors)]
            plt.gca().add_patch(
                PolygonPatch(polygon, alpha=0.2, ec='black',
                             fc=color_for_clust))
        figure.savefig(args.draw)

    log.info("Writing to: %s", args.output)

    features = []
    for i, poly in enumerate(output_polygons):
        feature = geojson.Feature(
            id=i,
            geometry=poly,
            properties={
                'clust': poly.cluster
            }
        )
        features.append(feature)
    feature_collection = geojson.FeatureCollection(features)

    with open(args.output, 'w') as outputfd:
        geojson.dump(feature_collection, outputfd, indent=2)
