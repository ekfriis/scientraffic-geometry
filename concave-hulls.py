#!/usr/bin/env python

'''

Find the concave hulls of a set of points using alpha shapes

Author: Evan K. Friis

'''

import argparse
from collections import namedtuple
import gzip
import itertools
import logging
import math
import operator

from descartes import PolygonPatch
from shapely.geometry import MultiLineString, MultiPolygon
from shapely.ops import cascaded_union, polygonize
from shapely.wkt import dumps as dump_shape
import matplotlib.pyplot as plt
import numpy as np
from scipy.spatial import Delaunay

log = logging.getLogger(__name__)

NodeInfo = namedtuple('NodeInfo', ['id', 'lat', 'lon', 'clust'])


def read_clusters(gzipped_file):
    """Yield node and cluster info from a gzip file"""
    with gzip.open(gzipped_file, 'rb') as fd:
        for line in fd:
            fields = [int(x) for x in line.strip().split()]
            yield NodeInfo(*fields)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'input', metavar='communities.gz',
        help='Gzipped communities, generated by communities.py')
    parser.add_argument(
        'output', metavar='community_shapes.gz',
        help='Gzipped WKT output polygons')
    parser.add_argument(
        '--cut', default=10, type=float,
        help='alpha parameter cut')

    parser.add_argument(
        '--draw', nargs='+', metavar='id',
        type=int, help='Draw specified cluster IDs')

    args = parser.parse_args()

    logging.basicConfig()
    log.setLevel(logging.INFO)

    clustered_nodes = itertools.groupby(
        read_clusters(args.input),
        operator.attrgetter('clust')
    )

    with gzip.open(args.output, 'wb') as outputfd:
        for clustidx, nodes in clustered_nodes:
            log.info("Processing cluster %i", clustidx)
            node_list = list(nodes)

            # from http://sgillies.net/blog/1155/the-fading-shape-of-alpha/
            points = np.array([(x.lat, x.lon) for x in node_list])
            max_x, max_y = np.max(points, axis=0)
            min_x, min_y = np.min(points, axis=0)
            log.info("Found %i nodes, bounded in x by (%i, %i)"
                     " and y by (%i, %i)",
                     len(points), min_x, max_x, min_y, max_y)
            size = max(max_x - min_x, max_y - min_y)

            tri = Delaunay(points)
            log.info("Found %i Delaunay triangles", len(tri.vertices))

            edge_points = []
            edges = set()

            def add_edge(i, j):
                """Add a line between the i-th and j-th points

                If not in the list already
                """
                if (i, j) in edges or (j, i) in edges:
                    # already added
                    return
                edges.add((i, j))
                edge_points.append(points[[i, j]])
            # loop over triangles:
            # ia, ib, ic = indices of corner points of the triangle
            for ia, ib, ic in tri.vertices:

                pa = points[ia]
                pb = points[ib]
                pc = points[ic]

                # Lengths of sides of triangle
                a = math.sqrt((pa[0]-pb[0])**2 + (pa[1]-pb[1])**2)
                b = math.sqrt((pb[0]-pc[0])**2 + (pb[1]-pc[1])**2)
                c = math.sqrt((pc[0]-pa[0])**2 + (pc[1]-pa[1])**2)

                # Semiperimeter of triangle
                s = (a + b + c)/2.0

                argument = s*(s-a)*(s-b)*(s-c)
                if argument < 0:
                    continue

                # Area of triangle by Heron's formula
                area = math.sqrt(argument)

                if area <= 0:
                    continue

                circum_r = a*b*c/(4.0*area)

                # Here's the radius filter.
                if circum_r / size < 1.0 / args.cut:
                    add_edge(ia, ib)
                    add_edge(ib, ic)
                    add_edge(ic, ia)

            log.info("After filter, %i edges remain", len(edge_points))

            log.info("Building line string")
            m = MultiLineString(edge_points)
            log.info("Polygonizing")
            triangles = list(polygonize(m))
            log.info("Unionizing")
            polygon = cascaded_union(triangles)

            best_polygon = polygon
            best_area = polygon.area

            if isinstance(polygon, MultiPolygon):
                best_area = 0
                log.info("Multi polygons detected")
                for ip, subpoly in enumerate(polygon):
                    #log.info("Poly %i - area: %f", ip, subpoly.area)
                    if subpoly.area > best_area:
                        best_polygon = subpoly
                        best_area = subpoly.area
            log.info("Found main polygon with area: %f", best_area)

            if args.draw and clustidx in args.draw:
                fig = plt.figure()
                plt.title("Cluster %i" % clustidx)
                plt.gca().add_patch(PolygonPatch(best_polygon, alpha=0.5))
                plt.gca().autoscale(tight=False)
                plt.plot([x[0] for x in points],
                         [x[1] for x in points], 'o', hold=1)
                fig.savefig("cluster_%i.png" % clustidx)

            outputfd.write(dump_shape(best_polygon) + '\n')
